#!/usr/bin/env node

/**
 * Comprehensive HTS + Wallet Workflow Test
 * This script tests the end-to-end integration between Hedera Token Service
 * and Wallet functionality in a Next.js project generated by APIX
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Test configuration
const TEST_CONFIG = {
  testProject: 'apix-test-project',
  timeout: 30000,
  expectedFiles: {
    // Wallet files
    'contexts/WalletContext.tsx': 'Wallet context with state management',
    'hooks/useWalletOperations.tsx': 'Wallet operations hook',
    'components/WalletConnect.tsx': 'Wallet connection component',
    'components/WalletConnectionModal.tsx': 'Wallet connection modal',
    'lib/hedera/wallet-service.ts': 'Wallet service utilities',
    'lib/hedera/transaction-signer.ts': 'Transaction signing abstraction',
    
    // HTS files  
    'lib/hedera/hts-operations.ts': 'Basic HTS operations',
    'lib/hedera/hts-wallet-operations.ts': 'Wallet-integrated HTS operations',
    'hooks/useTokens.tsx': 'Token operations hook',
    'hooks/useTokensWithWallet.tsx': 'Wallet-integrated token operations',
    'components/TokenManager.tsx': 'Token management UI',
    'components/TransactionStatus.tsx': 'Transaction status display',
    
    // API routes (Next.js only)
    'pages/api/tokens/create.ts': 'Token creation API endpoint',
    'pages/api/tokens/mint.ts': 'Token minting API endpoint', 
    'pages/api/tokens/transfer.ts': 'Token transfer API endpoint',
    'pages/api/tokens/info.ts': 'Token info API endpoint',
    
    // Shared files
    'lib/hedera/hedera-client.ts': 'Hedera client configuration',
    'types/hedera.ts': 'TypeScript definitions',
    '.env.local': 'Environment configuration'
  },
  workflowTests: [
    'wallet-connection-flow',
    'hts-operations-flow', 
    'combined-workflow-flow',
    'error-handling-flow',
    'typescript-compilation',
    'dependency-validation'
  ]
};

console.log('🧪 Starting APIX HTS + Wallet Workflow Test\n');

// Helper functions
function log(message, type = 'info') {
  const icons = { info: 'ℹ️', success: '✅', error: '❌', warning: '⚠️' };
  console.log(`${icons[type]} ${message}`);
}

function runCommand(command, cwd = process.cwd()) {
  try {
    const result = execSync(command, { 
      cwd, 
      encoding: 'utf8', 
      stdio: ['inherit', 'pipe', 'pipe'],
      timeout: TEST_CONFIG.timeout 
    });
    return { success: true, output: result };
  } catch (error) {
    return { 
      success: false, 
      output: error.stdout || error.message,
      error: error.stderr || error.message 
    };
  }
}

function fileExists(filePath) {
  return fs.existsSync(filePath);
}

function readFile(filePath) {
  try {
    return fs.readFileSync(filePath, 'utf8');
  } catch (error) {
    return null;
  }
}

// Test Setup
async function setupTestProject() {
  log('Setting up test project...', 'info');
  
  // Clean up any existing test project
  if (fileExists(TEST_CONFIG.testProject)) {
    log('Removing existing test project...', 'warning');
    runCommand(`rmdir /s /q ${TEST_CONFIG.testProject}`);
  }
  
  // Create fresh Next.js project
  log('Creating Next.js project...', 'info');
  const createResult = runCommand(
    `npx create-next-app@latest ${TEST_CONFIG.testProject} --typescript --tailwind --eslint --app --src-dir --import-alias "@/*" --no-install`
  );
  
  if (!createResult.success) {
    throw new Error(`Failed to create test project: ${createResult.error}`);
  }
  
  // Install dependencies
  log('Installing dependencies...', 'info');
  const installResult = runCommand('npm install', TEST_CONFIG.testProject);
  
  if (!installResult.success) {
    throw new Error(`Failed to install dependencies: ${installResult.error}`);
  }
  
  log('Test project setup complete', 'success');
  return path.resolve(TEST_CONFIG.testProject);
}

// Test 1: Wallet Connection Flow
function testWalletConnectionFlow(projectPath) {
  log('\n1. Testing Wallet Connection Flow...', 'info');
  
  // Test APIX wallet integration
  log('  Adding wallet integration...', 'info');
  const walletResult = runCommand('apix add wallet --provider hashpack', projectPath);
  
  if (!walletResult.success) {
    throw new Error(`Wallet integration failed: ${walletResult.error}`);
  }
  
  // Check wallet files were generated
  const walletFiles = [
    'src/contexts/WalletContext.tsx',
    'src/hooks/useWalletOperations.tsx', 
    'src/components/WalletConnect.tsx',
    'src/lib/hedera/wallet-service.ts'
  ];
  
  let filesFound = 0;
  walletFiles.forEach(file => {
    const fullPath = path.join(projectPath, file);
    if (fileExists(fullPath)) {
      filesFound++;
      log(`    ✓ ${file}`, 'success');
    } else {
      log(`    ✗ ${file} (missing)`, 'error');
    }
  });
  
  if (filesFound === walletFiles.length) {
    log('  Wallet connection flow: PASSED', 'success');
    return true;
  } else {
    log(`  Wallet connection flow: FAILED (${filesFound}/${walletFiles.length} files)`, 'error');
    return false;
  }
}

// Test 2: HTS Operations Flow  
function testHTSOperationsFlow(projectPath) {
  log('\n2. Testing HTS Operations Flow...', 'info');
  
  // Test APIX HTS integration
  log('  Adding HTS integration...', 'info');
  const htsResult = runCommand('apix add hts --name "TestToken" --symbol "TEST"', projectPath);
  
  if (!htsResult.success) {
    throw new Error(`HTS integration failed: ${htsResult.error}`);
  }
  
  // Check HTS files were generated
  const htsFiles = [
    'src/lib/hedera/hts-operations.ts',
    'src/lib/hedera/hts-wallet-operations.ts',
    'src/hooks/useTokens.tsx',
    'src/hooks/useTokensWithWallet.tsx',
    'src/components/TokenManager.tsx',
    'src/pages/api/tokens/create.ts'
  ];
  
  let filesFound = 0;
  htsFiles.forEach(file => {
    const fullPath = path.join(projectPath, file);
    if (fileExists(fullPath)) {
      filesFound++;
      log(`    ✓ ${file}`, 'success');
      
      // Check for wallet integration in HTS files
      const content = readFile(fullPath);
      if (content && content.includes('wallet') || content.includes('WalletManager')) {
        log(`    ✓ ${file} includes wallet integration`, 'success');
      }
    } else {
      log(`    ✗ ${file} (missing)`, 'error');
    }
  });
  
  if (filesFound >= htsFiles.length * 0.8) { // Allow for some flexibility
    log('  HTS operations flow: PASSED', 'success');
    return true;
  } else {
    log(`  HTS operations flow: FAILED (${filesFound}/${htsFiles.length} files)`, 'error');
    return false;
  }
}

// Test 3: Combined Workflow Flow
function testCombinedWorkflow(projectPath) {
  log('\n3. Testing Combined Workflow Integration...', 'info');
  
  // Check that HTS + Wallet files work together
  const combinedFiles = {
    'src/lib/hedera/hts-wallet-operations.ts': [
      'walletService',
      'TransactionSigner', 
      'HTSWalletManager',
      'createToken',
      'transferToken'
    ],
    'src/hooks/useTokensWithWallet.tsx': [
      'useWallet',
      'useTokensWithWallet',
      'canPerformOperations',
      'createToken',
      'transferToken'
    ],
    'src/components/TokenManager.tsx': [
      'useWallet',
      'useTokens',
      'wallet.isConnected',
      'createToken',
      'transferToken'
    ]
  };
  
  let integrationScore = 0;
  let totalChecks = 0;
  
  Object.entries(combinedFiles).forEach(([filePath, requiredPatterns]) => {
    const fullPath = path.join(projectPath, filePath);
    if (fileExists(fullPath)) {
      const content = readFile(fullPath);
      if (content) {
        const foundPatterns = requiredPatterns.filter(pattern => 
          content.includes(pattern)
        );
        
        integrationScore += foundPatterns.length;
        totalChecks += requiredPatterns.length;
        
        log(`    ✓ ${filePath}: ${foundPatterns.length}/${requiredPatterns.length} patterns`, 
            foundPatterns.length >= requiredPatterns.length * 0.8 ? 'success' : 'warning');
      }
    } else {
      log(`    ✗ ${filePath} (missing)`, 'error');
      totalChecks += requiredPatterns.length;
    }
  });
  
  const integrationPercentage = (integrationScore / totalChecks) * 100;
  if (integrationPercentage >= 75) {
    log(`  Combined workflow: PASSED (${integrationPercentage.toFixed(1)}% integration)`, 'success');
    return true;
  } else {
    log(`  Combined workflow: FAILED (${integrationPercentage.toFixed(1)}% integration)`, 'error');
    return false;
  }
}

// Test 4: Error Handling Flow
function testErrorHandling(projectPath) {
  log('\n4. Testing Error Handling...', 'info');
  
  // Check error handling patterns in key files
  const errorHandlingFiles = [
    'src/lib/hedera/hts-wallet-operations.ts',
    'src/hooks/useTokensWithWallet.tsx', 
    'src/components/TokenManager.tsx'
  ];
  
  let errorHandlingScore = 0;
  const errorPatterns = [
    'try.*catch',
    'Error\\(',
    'throw new Error',
    'wallet not connected',
    'error handling',
    'setError'
  ];
  
  errorHandlingFiles.forEach(filePath => {
    const fullPath = path.join(projectPath, filePath);
    if (fileExists(fullPath)) {
      const content = readFile(fullPath);
      if (content) {
        const foundPatterns = errorPatterns.filter(pattern => 
          new RegExp(pattern, 'i').test(content)
        );
        
        errorHandlingScore += foundPatterns.length;
        log(`    ✓ ${filePath}: ${foundPatterns.length}/${errorPatterns.length} error patterns`, 
            foundPatterns.length >= 3 ? 'success' : 'warning');
      }
    }
  });
  
  if (errorHandlingScore >= 12) { // At least 4 patterns per file on average
    log('  Error handling: PASSED', 'success');
    return true;
  } else {
    log(`  Error handling: FAILED (${errorHandlingScore} patterns found)`, 'error');
    return false;
  }
}

// Test 5: TypeScript Compilation
function testTypeScriptCompilation(projectPath) {
  log('\n5. Testing TypeScript Compilation...', 'info');
  
  // Run TypeScript check
  const tscResult = runCommand('npx tsc --noEmit', projectPath);
  
  if (tscResult.success) {
    log('  TypeScript compilation: PASSED', 'success');
    return true;
  } else {
    log('  TypeScript compilation: FAILED', 'error');
    log(`  Errors: ${tscResult.error}`, 'error');
    return false;
  }
}

// Test 6: Dependency Validation
function testDependencies(projectPath) {
  log('\n6. Testing Dependencies...', 'info');
  
  const packageJsonPath = path.join(projectPath, 'package.json');
  if (!fileExists(packageJsonPath)) {
    log('  Dependencies: FAILED (no package.json)', 'error');
    return false;
  }
  
  const packageJson = JSON.parse(readFile(packageJsonPath));
  const requiredDeps = [
    '@hashgraph/sdk',
    'react',
    'next'
  ];
  
  let depsFound = 0;
  requiredDeps.forEach(dep => {
    if (packageJson.dependencies && packageJson.dependencies[dep]) {
      log(`    ✓ ${dep}`, 'success');
      depsFound++;
    } else {
      log(`    ✗ ${dep} (missing)`, 'error');
    }
  });
  
  if (depsFound === requiredDeps.length) {
    log('  Dependencies: PASSED', 'success');
    return true;
  } else {
    log(`  Dependencies: FAILED (${depsFound}/${requiredDeps.length})`, 'error');
    return false;
  }
}

// Main test runner
async function runWorkflowTests() {
  let projectPath;
  const testResults = {};
  
  try {
    // Setup
    projectPath = await setupTestProject();
    
    // Run all workflow tests
    testResults.walletFlow = testWalletConnectionFlow(projectPath);
    testResults.htsFlow = testHTSOperationsFlow(projectPath);
    testResults.combinedFlow = testCombinedWorkflow(projectPath);
    testResults.errorHandling = testErrorHandling(projectPath);
    testResults.typescript = testTypeScriptCompilation(projectPath);
    testResults.dependencies = testDependencies(projectPath);
    
  } catch (error) {
    log(`Test execution failed: ${error.message}`, 'error');
    testResults.error = error.message;
  }
  
  // Generate report
  log('\n📊 Test Results Summary:', 'info');
  log('========================', 'info');
  
  const passedTests = Object.values(testResults).filter(Boolean).length;
  const totalTests = Object.keys(testResults).length;
  const errorTests = testResults.error ? 1 : 0;
  const successRate = ((passedTests - errorTests) / (totalTests - errorTests)) * 100;
  
  Object.entries(testResults).forEach(([testName, passed]) => {
    if (testName !== 'error') {
      log(`${testName}: ${passed ? 'PASS' : 'FAIL'}`, passed ? 'success' : 'error');
    }
  });
  
  if (testResults.error) {
    log(`Execution Error: ${testResults.error}`, 'error');
  }
  
  log(`\nOverall Success Rate: ${successRate.toFixed(1)}%`, 
      successRate >= 80 ? 'success' : successRate >= 60 ? 'warning' : 'error');
  
  // Cleanup
  if (projectPath && fileExists(projectPath)) {
    log('\nCleaning up test project...', 'info');
    // runCommand(`rmdir /s /q ${TEST_CONFIG.testProject}`);
    log('Test project kept for manual inspection', 'info');
  }
  
  return {
    passedTests,
    totalTests: totalTests - errorTests,
    successRate,
    results: testResults
  };
}

// Run tests if called directly
if (require.main === module) {
  runWorkflowTests()
    .then(results => {
      console.log('\n🎯 HTS + Wallet Workflow Test Complete');
      process.exit(results.successRate >= 80 ? 0 : 1);
    })
    .catch(error => {
      console.error('❌ Test runner failed:', error);
      process.exit(1);
    });
}

module.exports = { runWorkflowTests };